# 图

## 基本概念

### 定义

顶点一定非空，其余无要求

有向图

无向图

简单图（数据结构仅讨论简单图，不存在到自己的边）

多重图（数据结构不讨论）

完全图：所有节点都有到其他节点的边

子图：边和点都是子集，若仅边是子集，那么就构成了生成子图

联通、联通图、联通分量：无向图之中顶点到其他顶点都有路径可以到达

强联通图、强联通分量：有向图的联通图

生成树和森林：包含图之中所有顶点的一个最小联通子图

度

带权图

简单路径：除了第一个和最后一个点，其他点都不重复出现

## 图的存储与基本操作

### 邻接矩阵法

两个数组，一个一维数组存储节点的个数；一个二维数组存储节点的边的信息

如果是对称矩阵的话，那么就表示图是无向图；但如果矩阵是非对称的，表示图是有向图；计算入度和出度的时候就需要分开计算

### 邻接表法

建立一个顶点的链表，然后每个顶点链接到指向的节点（边集）

求出度简单 入度较为复杂

### 十字链表法（有向图）

顶点：值、第一个出度、第一个入度

弧节点：尾域、头域（依次表示头和尾在图之中的位置）、头指针、尾指针、信息

### 邻接矩阵法（无向图）

顶点：信息、第一条边的地址

边：搜索位、ivex、ilink（指向i相同的下一条边）、jvex、jlink（指向j相同的下一条边）、信息

## 图的遍历

### 广度优先

```c
bool visited[100];
Queue Q=new Queue;
void BFSTraverse(Graph G){
  for(int i=0;i<G.num;i++)
    visited[i]=false;
  for(int i=0;i<G.num;i++){
    if(!visited[i]){
      BFS(G,i);
    }
  }
}
void BFS(Graph G,int v){
  visit(v);	//访问输出
  visited[v]=true;
  EnQueue[Q,v];
  while(!Empty(Q)){
    DeQueue(Q,v);
    for(int w=FirstNeighbour(G,v);w>=0;w=NextNeighbour(G,v)){
      EnQueue(Q,w);
      visit(w);
      visited[w]=true;
    }
  }
}
```

空间复杂度：和顶点数目正比

时间复杂度：如果是矩阵存取就是O(V^2)；如果是邻接表存取就是O(V+E)

另外，我们可以根据遍历的结果获得一棵广度优先遍历生成树

### 深度优先

```c
bool visited[100];
void DFSTraverse(Graph G){
  for(int i=0;i<G.num;i++)
    visited[i]=false;
  for(int i=0;i<G.num;i++){
    if(!visited[i]){
      DFS(G,i);
    }
}
void DFS(Graph G,int i){
  visit(i);
  visited[w]=true;
  for(int w=FirstNeighbour(G,v);w>=0;w=NextNeighbour(G,v)){
    	DFS(G,w);
  }
}
  
```

空间复杂度：和顶点数目正比

时间复杂度：如果是矩阵存取就是O(V^2)；如果是邻接表存取就是O(V+E)

另外，我们可以根据遍历的结果获得一棵深度优先遍历生成树

## 图的应用

### 最小生成树

最小生成树的图不是唯一的，但是最小的路径是唯一的，同时边的数量为顶点的数目-1

#### prim算法

每次都是添加到目前的树之中最小的边的点

时间复杂度为O(V^2)

#### kruskal算法

每次选最小的边

时间复杂度为O(ElogE)

### 最短路近

#### 狄杰斯特拉算法

```c
设置辅助数组dist[]和path[]
dist[]：记录从原点开始到其他点的最短路径长度
path[]：记录原点到其他顶点最短路径的前驱节点
arcs[][]：邻接矩阵
执行步骤：
1.初始化，集合S初始为{0}，dist初始值为原点到其他点的距离：如果不可直接到达那么就为无穷大
2.从顶点集合之中选出一个点Vj，到集合的长度为最小值，加入集合
3.修改从v0出发到其他点的距离dist[],如果dist[j]+arcs[j][k]<dist[k]，那么就dist[k]=dist[j]+arcs[j][k]
```

狄杰斯特拉算法不适用于负的权值

#### 弗洛伊德算法

```
算法的思想是不断地在两个顶点之间加入其他顶点，判断值有没有变化。如果变小了，则修改最短路径
每次进行循环，如果两个点之间加入了节点k之后距离变小了，就修改最短路径
```

### 有向无环图

#### 表达式

```
1.操作数不重复写一排
2.运算符从左往右标顺序
3.加入运算符，同时注意分层
4.从底向上合并
```



#### 拓扑排序

每一个顶点仅出现一次并且不存在回路

```
输出操作：每一次选一个入度为0的点输出
然后切断从这个点开始到其他点的边
```

#### 逆拓扑排序

出度为0则出度

#### 关键路径

顶点表示事件、边表示活动

关键路径上的边为关键活动

```
事件发生的最早时间：从原点到目的点的最长路径，选取最大的值
事件的最迟发生时间
活动的最早开始时间
活动的最晚开始时间：从终点往前走，选取最小的值
```

缩短关键路径可以减短工期，但是如果有多条关键路径那么不一定

关键路径一直减少会变成非关键路径