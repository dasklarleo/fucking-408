# 内存管理

## 程序执行过程

程序的执行之前需要进行一系列的准备工作，包括编译、链接、装载

### 编译

对用户源程序进行编译，形成若干目标模块

主要任务就是将编写的代码转化成二进制的代码的过程

### 链接

将目标模块以及所需要的库函数链接在一起，形成一个完整的可装入模块

链接可以分为动态链接和静态链接

#### 静态链接

将程序与其他所依赖的目标文件链接好之后在装入内存之中运行

主要解决：

1. 相对地址的修改：链接之后，程序内部的相对地址都变成了基于某个地址的相对地址，因此对地址要进行修改
2. 变换外部调用符号：

#### 动态链接

程序在运行的时候再进行链接

可以分为装入时动态链接和运行时动态链接

##### 装入时动态链接

程序边进行装入变进行链接，有以下的优点：

1. 便于模块修改和更新：由于各个模块都是分开存放的，可以单独地对模块进行修改
2. 便于共享

##### 运行时动态链接

程序只有在运行的时候才对需要的模块进行链接

### 装入

将程序装入内存

#### 绝对装入

操作系统根据情况将程序装入到内存之中合适的位置

#### 可重定位装入

重定位：程序装入内存时对指令和数据的修改

#### 动态运行时装入

进程由于会经常从内存之中换入和换出，每一次换入和换出之后与之前的内存地址的位置可能不会相同，所以需要对程序进行动态重定位程序只有在执行的时候才进行逻辑地址（相对地址）到物理地址的转换，**需要重定位寄存器的支持**





## 内存分配方式

### 连续分配方式

#### 单一连续

简单地划分为系统区和用户区

#### 固定分区

为了适应于多道程序计算机的发展，将内存划分为若干区域，每次可以从作业队列之中挑选作业进入大小适应的内存区域之中

#### 动态分区

需要的数据机构，由于分区时动态的，因此需要对分区的个数，以及每一个分区的状态进行描述常用的有**空闲分区表和空闲分区链**

对每一个分区的是否被分配、大小、始址、区号进行描述

##### 操作

##### **分配内存**

1. FF：最简单、好、块
2. NF：末尾会形成小的碎片
3. BF：产生最多的外部碎片
4. WF：消耗大的内存块

##### 回收内存

注意回收的时候需要对相邻分区进行合并处理

#### 动态可重定位分区



### 分页分配方式

页=页帧=页框

地址结构：页号+页内偏移

每个页的地址结构组合起来就组成了页表

每个进程在获得处理机的时候都会从进程控制块之中的页表的地址放到计算机的页表寄存器之中，在页表寄存器之中存放着页表的数量、起始地址

具有快表的分页存储管理方式

**二级页表**：如果对页映射需页很多的页表项，那么可以对页表页分配一个页表，只有需要映射的时候再将页表放入内存之中。这样既可以减少主存的浪费又可以增加索引提高映射速度

### 分段分配方式

由于段的大小并不是一样的，因此段表需要额外加上段的大小，进程之中一般只有一个段表

由于段经常被分为若干代码段、数据段等不同的种类，而对于很多段是可以进行共享的，这一部分被称作共享代码段或者可重入代码段（由于是被共享，所以这一部分是不可以被修改的）

### 段页分配方式

先分段再进行分页，地址组成为：段号+页号+页内偏移

## 虚拟内存

### 原理

原理主要就是程序运行时的局部性原理，程序在进行运行的时候，有着时间局部性和空间局部性

时间局部性：这条指令在若干时间之后还会继续被访问

空间局部性：数组

### 特征

虚拟性：在逻辑上对内存进行扩充

多次性：程序无需一次全部装入内存，可以多次装入

对换性：可以将暂时不需要的代码或者数据暂时移出内存

### 硬件支持

段表（页表）作为主要的数据结构

中断机构：如果某一个进程正在访问的页不存在于内存之中，**就会产生一个缺页中断，同时进程也会进入阻塞态**。另外该中断属于内部中断，因此中断的处理是在执行指令的期间。在执行一条指令的时候也有可能产生多次中断

地址变换机构

## 内存扩充方法

### 请求分页

对页表项进行修改，变为下面所示的内容：

| 页号 | 物理快号             | 状态位             | 访问字段           | 修改位                       | 外存地址 |
| :--: | -------------------- | ------------------ | ------------------ | ---------------------------- | -------- |
|      | 对应到辅存的物理快号 | 是否存在于内存之中 | 供换页算法进行参考 | 替换出内存的时候是否需要写回 |          |
|      |                      |                    |                    |                              |          |

### 内存置换算法

1. OPT：选取一个未来使用时间距离现在最长的页面替换出去，是理想状态

2. FIFO：基于队列的算法，最先进来的最先出去，会产生Nelady异常

3. LRU：基于堆栈类算法，将最近最长时间咩有使用的页面替换出去，需要在页面设置一个访问字段，记录从上次访问以来所经历的时间，替换时选取一个最大的替换出去

4. CLOCK：将页面分为下面的四类：并且分别设立访问为：u、m

   1. 最近没有被访问、没有被修改

   2. 被访问、没有被修改

   3. 没有被访问、被修改

   4. 被访问、被修改

      算法在执行时：

      1. 寻找u=0、m=0的块，替换出去，没有找到进行步骤二
      2. 重新进行扫描，将u=0、m=1的块替换出去，对于跳过的块，将u修改为0；如果还是没有找到就重复步骤一
      3. 

